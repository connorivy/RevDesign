{% extends "model/base.html" %}
{% load static %}
{% block getMesh %}
<script type="text/javascript">
    $(document).ready(function () {
        $("#sidebar").mCustomScrollbar({
            theme: "minimal"
        });

        $('#sidebarCollapse').on('click', function () {
            $('#sidebar, #content').toggleClass('active');
            $('.collapse.in').toggleClass('in');
            $('a[aria-expanded=true]').attr('aria-expanded', 'false');
        });
    });

    function getFloorMesh() {
      if ( v.interactions.selectedObjectsUserData.length == 0 ) {
          console.log('No Floor Selected')
          return
      } else if ( v.interactions.selectedObjectsUserData.length > 1 ) {
          console.log( 'Too many objects selected')
          return
      } 
      var segments = v.interactions.selectedObjectsUserData[0].outline.segments;
      var coords = new Set();
      for (var i = 0; i < segments.length; i++) {
          coords.add(JSON.stringify([+(segments[i].start.x).toFixed(6), +(segments[i].start.y).toFixed(6)]))
          coords.add(JSON.stringify([+(segments[i].end.x).toFixed(6), +(segments[i].end.y).toFixed(6)]))
      }
      if (segments.length != coords.size) {
          console.log('WARNING: number of unique coordinates does not equal number of segments')
      }

      var coordArrayFloor = Array.from(coords, e => JSON.parse(e));
      // 'close polygon loop' in order for the points in poly function to work
      coordArrayFloor.push(coordArrayFloor[0])

      // get all shearwalls
      var coordDictWalls = {}
      var p0x = false
      var p1x = false
      var p0y = false
      var p1y = false
      var p0inPoly = [false, null]
      var p1inPoly = [false, null]
      var p0IsCorner = false
      var p1IsCorner = false
      var distOfP0 = 0
      var distOfP1 = 0
      for (var i = 0; i < v.sceneManager.shearWalls.length; i++) {
          if (v.sceneManager.shearWalls[i].userData.length < 1) {
              console.log('Cannot have a shear wall less than 1\'')
              continue
          }
          p0x = +v.sceneManager.shearWalls[i].userData.start.x.toFixed(6)
          p0y = +v.sceneManager.shearWalls[i].userData.start.y.toFixed(6)
          p1x = +v.sceneManager.shearWalls[i].userData.end.x.toFixed(6)
          p1y = +v.sceneManager.shearWalls[i].userData.end.y.toFixed(6)
          console.log('points of line', [p0x, p0y], [p1x, p1y])
          p0inPoly = pointInPolygon([p0x, p0y], [coordArrayFloor], 3)
          p1inPoly = pointInPolygon([p1x, p1y], [coordArrayFloor], 3)
          console.log('points in poly', p0inPoly, p1inPoly)
          // one or both of the points is outside the slab, don't count it.
          if (p0inPoly[0] === false || p1inPoly[0] === false) {
              console.log('outside slab')
              continue
          }
          // both points are inside the slab, yay
          if (p0inPoly[0] == true && p1inPoly[0] == true) {
              console.log('inside slab')
          // both points are on the border of the polygon
          } else if (p0inPoly[0] === 0 && p1inPoly[0] === 0) {
              console.log('on perim')
              console.log(coordArrayFloor[p0inPoly[1]],coordArrayFloor[p0inPoly[1]+1],[p0x, p0y],[p1x, p1y])
              p0IsCorner = isEqual2DList(coordArrayFloor[p0inPoly[1]],[p0x, p0y]) || isEqual2DList(coordArrayFloor[p0inPoly[1]+1],[p0x, p0y])
              p1IsCorner = isEqual2DList(coordArrayFloor[p1inPoly[1]],[p1x, p1y]) || isEqual2DList(coordArrayFloor[p1inPoly[1]+1],[p1x, p1y])

              // if both are corners, just add to coord array walls
              if (p0IsCorner && p1IsCorner) {
                  console.log('both corners')
              } 
              else if (p0IsCorner) {
                  console.log('p0 is corner')
                  coordArrayFloor.splice(p1inPoly[1]+1, 0, [p1x, p1y])
              } else if (p1IsCorner) {
                  console.log('p1 is corner')
                  coordArrayFloor.splice(p0inPoly[1]+1, 0, [p0x, p0y])
              // neither point is on a corner
              } else {
                  console.log('no corners')
                  // find the point that has the largest index in the list, insert there, and then insert the new point into the smaller index
                  if (p0inPoly[1] > p1inPoly[1]) {
                      coordArrayFloor.splice(p0inPoly[1]+1, 0, [p0x, p0y])
                      coordArrayFloor.splice(p1inPoly[1]+1, 0, [p1x, p1y])
                  } else if (p0inPoly[1] < p1inPoly[1]) {
                      coordArrayFloor.splice(p1inPoly[1]+1, 0, [p1x, p1y])
                      coordArrayFloor.splice(p0inPoly[1]+1, 0, [p0x, p0y])
                  // if the indicies are the same, then the points are on the same line. Find the one furthest away from the corner point and insert that right after the point,
                  // then insert the closer point right after the corner point in the coodArrayFloor
                  } else {
                      distOfP0 = distanceFormula([p0x, p0y], coordArrayFloor[p0inPoly[1]])
                      distOfP1 = distanceFormula([p1x, p1y], coordArrayFloor[p0inPoly[1]])
                      // if p0 is closer, insert p1 then p0
                      if (distOfP0 < distOfP1) {
                          coordArrayFloor.splice(p0inPoly[1]+1, 0, [p1x, p1y])
                          coordArrayFloor.splice(p0inPoly[1]+1, 0, [p0x, p0y])
                      } else {
                          coordArrayFloor.splice(p0inPoly[1]+1, 0, [p0x, p0y])
                          coordArrayFloor.splice(p0inPoly[1]+1, 0, [p1x, p1y])
                      }
                  }
              }
          } else if (p0inPoly[0] === 0) {
              console.log('p0 on perim')
              coordArrayFloor.splice(p0inPoly[1]+1, 0, [p0x, p0y])
          } else if (p1inPoly[0] === 0) {
              console.log('p1 on perim')
              coordArrayFloor.splice(p1inPoly[1]+1, 0, [p1x, p1y])
          }
          coordDictWalls[v.sceneManager.shearWalls[i].userData.id] = [
              p0x, 
              p0y, 
              p1x,
              p1y,
          ]
      }

      // pop value added earlier to close loop. This is how sfepy pygmsh prefers it's polygons
      coordArrayFloor.pop()
      console.log(coordArrayFloor)
      // console.log(localStorage.getItem( 'prevLoadUrl' ), v.loaders[localStorage.getItem( 'prevLoadUrl' )].serverUrl, v.loaders[localStorage.getItem( 'prevLoadUrl' )].streamId)

      // POST request
      $.ajax({
          type: 'POST',
          url: "{% url 'get_floor_mesh' %}",
          data: {
              'coord_list_floor': JSON.stringify(coordArrayFloor),
              'coord_dict_walls': JSON.stringify(coordDictWalls),
              'HOST': v.loaders[localStorage.getItem( 'prevLoadUrl' )].serverUrl,
              'STREAM_ID': v.loaders[localStorage.getItem( 'prevLoadUrl' )].streamId,
              'COMMIT_ID': v.loaders[localStorage.getItem( 'prevLoadUrl' )].objectId,
              'FLOOR_ID': v.interactions.selectedObjectsUserData[0].id
          },
          success: function (response) {
              console.log(response)
              v.addAttributesToObjects(v.sceneManager.sceneObjects.allLineObjects, response['shear_wall_data'])
          },
          error: function (response) {
              console.log('error')
              console.log(response)
          }
      })
  };

  function pointInPolygon(p, polygon, numDecimals) {
      let i = 0
      let ii = 0
      let k = 0
      let f = 0
      let u1 = 0
      let v1 = 0
      let u2 = 0
      let v2 = 0
      let currentP = null
      let nextP = null

      const x = +p[0].toFixed(numDecimals)
      const y = +p[1].toFixed(numDecimals)

      const numContours = polygon.length
      for (i; i < numContours; i++) {
          ii = 0
          const contourLen = polygon[i].length - 1
          const contour = polygon[i]

          currentP = contour[0]
          if (currentP[0] !== contour[contourLen][0] &&
              currentP[1] !== contour[contourLen][1]) {
              throw new Error('First and last coordinates in a ring must be the same')
          }

          u1 = +currentP[0].toFixed(numDecimals) - x
          v1 = +currentP[1].toFixed(numDecimals) - y

          for (ii; ii < contourLen; ii++) {
              nextP = contour[ii + 1]

              v2 = +nextP[1].toFixed(numDecimals) - y

              if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {
                  currentP = nextP
                  v1 = v2
                  u1 = +currentP[0].toFixed(numDecimals) - x
                  continue
              }

              u2 = +nextP[0].toFixed(numDecimals) - x

              if (v2 > 0 && v1 <= 0) {
                  f = (u1 * v2) - (u2 * v1)
                  if (f > 0) k = k + 1
                  else if (f === 0) return [0, ii]
              } else if (v1 > 0 && v2 <= 0) {
                  f = (u1 * v2) - (u2 * v1)
                  if (f < 0) k = k + 1
                  else if (f === 0) return [0, ii]
              } else if (v2 === 0 && v1 < 0) {
                  f = (u1 * v2) - (u2 * v1)
                  if (f === 0) return [0, ii]
              } else if (v1 === 0 && v2 < 0) {
                  f = u1 * v2 - u2 * v1
                  if (f === 0) return [0, ii]
              } else if (v1 === 0 && v2 === 0) {
                  if (u2 <= 0 && u1 >= 0) {
                      return [0, ii]
                  } else if (u1 <= 0 && u2 >= 0) {
                      return [0, ii]
                  }
              }
              currentP = nextP
              v1 = v2
              u1 = u2
          }
      }

      if (k % 2 === 0) return [false, null]
      return [true, null]
  }

  function isEqual2DList(p1, p2) {
      // tolerance is 6"
      tol = 5e-1
      if (Math.abs(p2[0] - p1[0]) < tol && Math.abs(p2[1] - p1[1]) < tol) {
          return true
      } 
      return false
  }

  function distanceFormula(p0, p1) {
      return Math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)
  }
  </script>
{% endblock getMesh %}